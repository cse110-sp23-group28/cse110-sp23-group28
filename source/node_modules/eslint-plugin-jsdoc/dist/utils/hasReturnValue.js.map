{"version":3,"file":"hasReturnValue.js","names":["isNewPromiseExpression","node","type","callee","name","isVoidPromise","_node$typeParameters","_node$typeParameters$","_node$typeParameters$2","typeParameters","params","undefinedKeywords","Set","hasReturnValue","throwOnNullReturn","promFilter","_node$returnType","_node$returnType$type","returnType","typeAnnotation","has","value","expression","body","some","bodyNode","consequent","alternate","block","handler","finalizer","cases","someCase","nde","argument","Error","exports","allBrancheshaveReturnValues","_node$returnType2","_node$returnType2$typ","lastBodyNode","slice","test","error","message","every","consNode","hasNonEmptyResolverCall","resolverName","arguments","length","undefined","_node$params$","elements","element","right","left","expressions","subExpression","properties","property","decorators","decorator","computed","key","declarations","id","init","quasi","object","source","hasValueOrExecutorHasNonEmptyResolveValue","anyPromiseAsReturn","allBranches","hasReturnMethod","promiseFilter","hasReturn","Boolean","prom"],"sources":["../../src/utils/hasReturnValue.js"],"sourcesContent":["/**\n * @typedef {import('estree').Node|\n *   import('@typescript-eslint/types').TSESTree.Node} ESTreeOrTypeScriptNode\n */\n\n/**\n * Checks if a node is a promise but has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n *\n * @param {ESTreeOrTypeScriptNode|undefined|null} node\n * @returns {boolean|undefined|null}\n */\nconst isNewPromiseExpression = (node) => {\n  return node && node.type === 'NewExpression' && node.callee.type === 'Identifier' &&\n    node.callee.name === 'Promise';\n};\n\n/**\n * @param {ESTreeOrTypeScriptNode|null|undefined} node\n * @returns {boolean}\n */\nconst isVoidPromise = (node) => {\n  return /** @type {import('@typescript-eslint/types').TSESTree.TSTypeReference} */ (\n    node\n  )?.typeParameters?.params?.[0]?.type === 'TSVoidKeyword';\n};\n\nconst undefinedKeywords = new Set([\n  'TSVoidKeyword', 'TSUndefinedKeyword', 'TSNeverKeyword',\n]);\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n *\n * @param {ESTreeOrTypeScriptNode|undefined|null} node\n * @param {boolean} [throwOnNullReturn]\n * @param {PromiseFilter} [promFilter]\n * @returns {boolean|undefined}\n */\n// eslint-disable-next-line complexity\nconst hasReturnValue = (node, throwOnNullReturn, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'TSDeclareFunction':\n  case 'TSFunctionType':\n  case 'TSMethodSignature': {\n    const type = node?.returnType?.typeAnnotation?.type;\n    return type && !undefinedKeywords.has(type);\n  }\n\n  case 'MethodDefinition':\n    return hasReturnValue(node.value, throwOnNullReturn, promFilter);\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return 'expression' in node && node.expression && (!isNewPromiseExpression(\n      node.body,\n    ) || !isVoidPromise(node.body)) ||\n      hasReturnValue(node.body, throwOnNullReturn, promFilter);\n  }\n\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return bodyNode.type !== 'FunctionDeclaration' && hasReturnValue(bodyNode, throwOnNullReturn, promFilter);\n    });\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasReturnValue(node.body, throwOnNullReturn, promFilter);\n  }\n\n  case 'IfStatement': {\n    return hasReturnValue(node.consequent, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.alternate, throwOnNullReturn, promFilter);\n  }\n\n  case 'TryStatement': {\n    return hasReturnValue(node.block, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.handler && node.handler.body, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.finalizer, throwOnNullReturn, promFilter);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasReturnValue(nde, throwOnNullReturn, promFilter);\n        });\n      },\n    );\n  }\n\n  case 'ReturnStatement': {\n    // void return does not count.\n    if (node.argument === null) {\n      if (throwOnNullReturn) {\n        throw new Error('Null return');\n      }\n\n      return false;\n    }\n\n    if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n      return promFilter(node.argument);\n    }\n\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n *\n * @param {ESTreeOrTypeScriptNode|null|undefined} node\n * @param {PromiseFilter} promFilter\n * @returns {undefined|boolean|ESTreeOrTypeScriptNode}\n */\n// eslint-disable-next-line complexity\nconst allBrancheshaveReturnValues = (node, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'TSDeclareFunction':\n  case 'TSFunctionType':\n  case 'TSMethodSignature': {\n    const type = node?.returnType?.typeAnnotation?.type;\n    return type && !undefinedKeywords.has(type);\n  }\n\n  // case 'MethodDefinition':\n  //   return allBrancheshaveReturnValues(node.value, promFilter);\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return 'expression' in node && node.expression && (!isNewPromiseExpression(node.body) || !isVoidPromise(node.body)) ||\n      allBrancheshaveReturnValues(node.body, promFilter) ||\n      /** @type {import('@typescript-eslint/types').TSESTree.BlockStatement} */\n      (node.body).body.some((nde) => {\n        return nde.type === 'ReturnStatement';\n      });\n  }\n\n  case 'BlockStatement': {\n    const lastBodyNode = node.body.slice(-1)[0];\n    return allBrancheshaveReturnValues(lastBodyNode, promFilter);\n  }\n\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n    if (\n      /**\n       * @type {import('@typescript-eslint/types').TSESTree.Literal}\n       */\n      (node.test).value === true\n    ) {\n      // If this is an infinite loop, we assume only one branch\n      //   is needed to provide a return\n      return hasReturnValue(node.body, false, promFilter);\n    }\n\n    // Fallthrough\n  case 'LabeledStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return allBrancheshaveReturnValues(node.body, promFilter);\n  }\n\n  case 'IfStatement': {\n    return allBrancheshaveReturnValues(node.consequent, promFilter) &&\n      allBrancheshaveReturnValues(node.alternate, promFilter);\n  }\n\n  case 'TryStatement': {\n    // If `finally` returns, all return\n    return node.finalizer && allBrancheshaveReturnValues(node.finalizer, promFilter) ||\n      // Return in `try`/`catch` may still occur despite `finally`\n      allBrancheshaveReturnValues(node.block, promFilter) &&\n        (!node.handler ||\n          allBrancheshaveReturnValues(node.handler && node.handler.body, promFilter)) &&\n          (!node.finalizer || (() => {\n            try {\n              hasReturnValue(node.finalizer, true, promFilter);\n            } catch (error) {\n              // istanbul ignore else\n              if (/** @type {Error} */ (error).message === 'Null return') {\n                return false;\n              }\n\n              // istanbul ignore next\n              throw error;\n            }\n\n            // As long as not an explicit empty return, then return true\n            return true;\n          })());\n  }\n\n  case 'SwitchStatement': {\n    return /** @type {import('@typescript-eslint/types').TSESTree.SwitchStatement} */ (node).cases.every(\n      (someCase) => {\n        return !someCase.consequent.some((consNode) => {\n          return consNode.type === 'BreakStatement' ||\n            consNode.type === 'ReturnStatement' && consNode.argument === null;\n        });\n      },\n    );\n  }\n\n  case 'ThrowStatement': {\n    return true;\n  }\n\n  case 'ReturnStatement': {\n    // void return does not count.\n    if (node.argument === null) {\n      return false;\n    }\n\n    if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n      return promFilter(node.argument);\n    }\n\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * @callback PromiseFilter\n * @param {ESTreeOrTypeScriptNode|undefined} node\n * @returns {boolean}\n */\n\n/**\n * Avoids further checking child nodes if a nested function shadows the\n * resolver, but otherwise, if name is used (by call or passed in as an\n * argument to another function), will be considered as non-empty.\n *\n * This could check for redeclaration of the resolver, but as such is\n * unlikely, we avoid the performance cost of checking everywhere for\n * (re)declarations or assignments.\n *\n * @param {import('@typescript-eslint/types').TSESTree.Node|null|undefined} node\n * @param {string} resolverName\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasNonEmptyResolverCall = (node, resolverName) => {\n  if (!node) {\n    return false;\n  }\n\n  // Arrow function without block\n  switch (node.type) {\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'OptionalCallExpression':\n  case 'CallExpression':\n    return /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n      node.callee\n    ).name === resolverName && (\n\n      // Implicit or explicit undefined\n      node.arguments.length > 1 || node.arguments[0] !== undefined\n    ) ||\n      node.arguments.some((nde) => {\n        // Being passed in to another function (which might invoke it)\n        return nde.type === 'Identifier' && nde.name === resolverName ||\n\n          // Handle nested items\n          hasNonEmptyResolverCall(nde, resolverName);\n      });\n  case 'ChainExpression':\n  case 'Decorator':\n  case 'ExpressionStatement':\n    return hasNonEmptyResolverCall(node.expression, resolverName);\n  case 'ClassBody':\n  case 'BlockStatement':\n    return node.body.some((bodyNode) => {\n      return hasNonEmptyResolverCall(bodyNode, resolverName);\n    });\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    // Shadowing\n    if (/** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n      node.params[0]\n    )?.name === resolverName) {\n      return false;\n    }\n\n    return hasNonEmptyResolverCall(node.body, resolverName);\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasNonEmptyResolverCall(node.body, resolverName);\n  }\n\n  case 'ConditionalExpression':\n  case 'IfStatement': {\n    return hasNonEmptyResolverCall(node.test, resolverName) ||\n      hasNonEmptyResolverCall(node.consequent, resolverName) ||\n      hasNonEmptyResolverCall(node.alternate, resolverName);\n  }\n\n  case 'TryStatement': {\n    return hasNonEmptyResolverCall(node.block, resolverName) ||\n      hasNonEmptyResolverCall(node.handler && node.handler.body, resolverName) ||\n      hasNonEmptyResolverCall(node.finalizer, resolverName);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasNonEmptyResolverCall(nde, resolverName);\n        });\n      },\n    );\n  }\n\n  case 'ArrayPattern':\n  case 'ArrayExpression':\n    return node.elements.some((element) => {\n      return hasNonEmptyResolverCall(element, resolverName);\n    });\n\n  case 'AssignmentPattern':\n    return hasNonEmptyResolverCall(node.right, resolverName);\n\n  case 'AssignmentExpression':\n  case 'BinaryExpression':\n  case 'LogicalExpression': {\n    return hasNonEmptyResolverCall(node.left, resolverName) ||\n      hasNonEmptyResolverCall(node.right, resolverName);\n  }\n\n  // Comma\n  case 'SequenceExpression':\n  case 'TemplateLiteral':\n    return node.expressions.some((subExpression) => {\n      return hasNonEmptyResolverCall(subExpression, resolverName);\n    });\n\n  case 'ObjectPattern':\n  case 'ObjectExpression':\n    return node.properties.some((property) => {\n      return hasNonEmptyResolverCall(property, resolverName);\n    });\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'ClassMethod':\n  case 'MethodDefinition':\n    return node.decorators && node.decorators.some((decorator) => {\n      return hasNonEmptyResolverCall(decorator, resolverName);\n    }) ||\n      node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'ObjectProperty':\n  /* eslint-disable no-fallthrough */\n  // istanbul ignore next -- In Babel?\n  case 'PropertyDefinition':\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'ClassProperty':\n  case 'Property':\n  /* eslint-enable no-fallthrough */\n    return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'ObjectMethod':\n    // @ts-expect-error\n    // istanbul ignore next -- In Babel?\n    return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      // @ts-expect-error\n      node.arguments.some((nde) => {\n        return hasNonEmptyResolverCall(nde, resolverName);\n      });\n\n  case 'ClassExpression':\n  case 'ClassDeclaration':\n    return hasNonEmptyResolverCall(node.body, resolverName);\n\n  case 'AwaitExpression':\n  case 'SpreadElement':\n  case 'UnaryExpression':\n  case 'YieldExpression':\n    return hasNonEmptyResolverCall(node.argument, resolverName);\n\n  case 'VariableDeclaration': {\n    return node.declarations.some((nde) => {\n      return hasNonEmptyResolverCall(nde, resolverName);\n    });\n  }\n\n  case 'VariableDeclarator': {\n    return hasNonEmptyResolverCall(node.id, resolverName) ||\n      hasNonEmptyResolverCall(node.init, resolverName);\n  }\n\n  case 'TaggedTemplateExpression':\n    return hasNonEmptyResolverCall(node.quasi, resolverName);\n\n  // @ts-expect-error Babel?\n  // ?.\n  // istanbul ignore next -- In Babel?\n  case 'OptionalMemberExpression':\n  case 'MemberExpression':\n    return hasNonEmptyResolverCall(node.object, resolverName) ||\n      hasNonEmptyResolverCall(node.property, resolverName);\n\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'Import':\n  case 'ImportExpression':\n    return hasNonEmptyResolverCall(node.source, resolverName);\n\n  case 'ReturnStatement': {\n    if (node.argument === null) {\n      return false;\n    }\n\n    return hasNonEmptyResolverCall(node.argument, resolverName);\n  }\n\n  /*\n  // Shouldn't need to parse literals/literal components, etc.\n\n  case 'Identifier':\n  case 'TemplateElement':\n  case 'Super':\n  // Exports not relevant in this context\n  */\n  default:\n    return false;\n  }\n};\n\n/**\n * Checks if a Promise executor has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n *\n * @param {ESTreeOrTypeScriptNode} node\n * @param {boolean} anyPromiseAsReturn\n * @param {boolean} [allBranches]\n * @returns {boolean}\n */\nconst hasValueOrExecutorHasNonEmptyResolveValue = (node, anyPromiseAsReturn, allBranches) => {\n  const hasReturnMethod = allBranches ?\n    /**\n     * @param {ESTreeOrTypeScriptNode} nde\n     * @param {PromiseFilter} promiseFilter\n     * @returns {boolean}\n     */\n    (nde, promiseFilter) => {\n      let hasReturn;\n      try {\n        hasReturn = hasReturnValue(nde, true, promiseFilter);\n      } catch (error) {\n        // istanbul ignore else\n        if (/** @type {Error} */ (error).message === 'Null return') {\n          return false;\n        }\n\n        // istanbul ignore next\n        throw error;\n      }\n\n      // `hasReturn` check needed since `throw` treated as valid return by\n      //   `allBrancheshaveReturnValues`\n      return Boolean(hasReturn && allBrancheshaveReturnValues(nde, promiseFilter));\n    } :\n    /**\n     * @param {ESTreeOrTypeScriptNode} nde\n     * @param {PromiseFilter} promiseFilter\n     * @returns {boolean}\n     */\n    (nde, promiseFilter) => {\n      return Boolean(hasReturnValue(nde, false, promiseFilter));\n    };\n\n  return hasReturnMethod(node, (prom) => {\n    if (anyPromiseAsReturn) {\n      return true;\n    }\n\n    if (isVoidPromise(prom)) {\n      return false;\n    }\n\n    const {\n      params,\n      body,\n    } =\n    /**\n     * @type {import('@typescript-eslint/types').TSESTree.FunctionExpression|\n     * import('@typescript-eslint/types').TSESTree.ArrowFunctionExpression}\n     */ (\n      /** @type {import('@typescript-eslint/types').TSESTree.NewExpression} */ (\n          prom\n        ).arguments[0]\n      ) || {};\n\n    if (!params?.length) {\n      return false;\n    }\n\n    const {\n      name: resolverName,\n    } = /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n      params[0]\n    );\n\n    return hasNonEmptyResolverCall(body, resolverName);\n  });\n};\n\nexport {\n  hasReturnValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n};\n"],"mappings":"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"}